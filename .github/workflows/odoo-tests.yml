# Odoo Unit Tests - Reusable Workflow
# Runs Odoo unit tests using odoo-docker-minimal
#
# Uses docker-compose with odoo-docker-minimal to run tests in a containerized
# environment with PostgreSQL. Follows the same pattern as Jenkins test execution.
#
# Note: Concurrency should be set in the calling workflow, not here.
# This allows the caller to define the concurrency group based on their context.
#
# TODO: REGISTRY_USER is currently set to a personal account (gustavo.aguiar@muchconsulting.de).
#       This should be replaced with a Harbor robot account for production use:
#       1. Create robot account in Harbor: Administration ‚Üí Robot Accounts
#       2. Update REGISTRY_USER secret to: robot$<robot-name>
#       3. Update REGISTRY_PASSWORD secret with the robot token

name: Odoo Unit Tests

on:
  workflow_call:
    inputs:
      odoo-version:
        description: 'Odoo version (14, 15, 16, 17, 18)'
        required: true
        type: string
      test-tags:
        description: 'Test tags to run (default: much_unit)'
        required: false
        type: string
        default: 'much_unit'
      strict-mode:
        description: 'Fail workflow on any test failure'
        required: false
        type: boolean
        default: false
      timeout-minutes:
        description: 'Test timeout in minutes'
        required: false
        type: number
        default: 30
      skip-dependencies:
        description: 'Skip cloning repository dependencies'
        required: false
        type: boolean
        default: false
    secrets:
      REGISTRY_URL:
        description: 'Docker registry URL for pulling Odoo images'
        required: false
      REGISTRY_USER:
        description: 'Docker registry username'
        required: false
      REGISTRY_PASSWORD:
        description: 'Docker registry password'
        required: false
      ENTERPRISE_TOKEN:
        description: 'Token for downloading enterprise modules'
        required: false
      DOCKER_MINIMAL_TOKEN:
        description: 'PAT for accessing odoo-docker-minimal repo (falls back to CONFIG_TOKEN)'
        required: false
      CONFIG_TOKEN:
        description: 'Fallback PAT for private repo access'
        required: false
    outputs:
      tests-passed:
        description: 'Whether all tests passed'
        value: ${{ jobs.test.outputs.tests-passed }}
      modules-tested:
        description: 'Comma-separated list of tested modules'
        value: ${{ jobs.test.outputs.modules-tested }}
      test-mode:
        description: 'Test mode used (push-all, pr-filtered, label-forced, *-fallback)'
        value: ${{ jobs.test.outputs.test-mode }}

jobs:
  test:
    name: Unit Tests (Odoo ${{ inputs.odoo-version }})
    runs-on: ubuntu-latest
    timeout-minutes: ${{ inputs.timeout-minutes }}
    permissions:
      contents: read
      pull-requests: write
    outputs:
      tests-passed: ${{ steps.summary.outputs.tests-passed }}
      modules-tested: ${{ steps.discover.outputs.modules }}
      test-mode: ${{ steps.discover.outputs.test_mode }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          ref: ${{ github.head_ref || github.ref }}
          fetch-depth: 0
          submodules: recursive

      - name: Cache repository dependencies
        if: inputs.skip-dependencies != true
        uses: actions/cache@v4
        with:
          path: ${{ github.workspace }}/deps
          key: odoo-deps-${{ inputs.odoo-version }}-${{ hashFiles('pyproject.toml') }}
          restore-keys: |
            odoo-deps-${{ inputs.odoo-version }}-

      - name: Clone repository dependencies
        id: clone-deps
        if: inputs.skip-dependencies != true
        env:
          GH_TOKEN: ${{ secrets.CONFIG_TOKEN || github.token }}
          ODOO_VERSION: ${{ inputs.odoo-version }}
        run: |
          echo "::group::Repository Dependencies"

          # Check for [odoo.dependencies] section
          if ! grep -q '^\[odoo\.dependencies\]' pyproject.toml 2>/dev/null; then
            echo "No [odoo.dependencies] section found"
            echo "::endgroup::"
            exit 0
          fi

          DEPS_DIR="${{ github.workspace }}/deps"
          mkdir -p "$DEPS_DIR"
          MAJOR_VERSION="${ODOO_VERSION%%.*}"

          # Parse and clone each dependency
          awk '/^\[odoo\.dependencies\]/{flag=1; next} /^\[/{flag=0} flag && /=/' pyproject.toml | \
          while IFS='=' read -r repo strategy; do
            # Clean up quotes and whitespace
            repo=$(echo "$repo" | tr -d ' "')
            strategy=$(echo "$strategy" | tr -d ' "{}' | sed 's/version[[:space:]]*=[[:space:]]*//')

            # Skip empty lines and comments
            [ -z "$repo" ] && continue
            echo "$repo" | grep -q '^#' && continue

            # Default to tag strategy
            [ -z "$strategy" ] && strategy="tag"

            REPO_NAME=$(basename "$repo")

            # Skip if already cached/cloned
            if [ -d "$DEPS_DIR/$REPO_NAME" ]; then
              echo "‚úì $REPO_NAME (cached)"
              continue
            fi

            # Resolve version based on strategy
            if [ "$strategy" = "tag" ]; then
              VERSION=$(gh api "repos/${repo}/tags" --jq '.[].name' 2>/dev/null | \
                        grep "^v${MAJOR_VERSION}\." | sort -V | tail -1)
              if [ -z "$VERSION" ]; then
                echo "::warning::No tag matching v${MAJOR_VERSION}.* found for $repo"
                continue
              fi
            elif [ "$strategy" = "branch" ]; then
              VERSION="${MAJOR_VERSION}.0"
            else
              VERSION="$strategy"
            fi

            echo "Cloning $repo @ $VERSION"
            if git clone --depth 1 --branch "$VERSION" \
              "https://x-access-token:${GH_TOKEN}@github.com/${repo}.git" \
              "$DEPS_DIR/$REPO_NAME" 2>/dev/null; then
              echo "‚úì $REPO_NAME @ $VERSION"
              rm -rf "$DEPS_DIR/$REPO_NAME/.git"
            else
              echo "::error::Failed to clone $repo @ $VERSION"
            fi
          done

          echo ""
          echo "Dependencies directory:"
          ls -la "$DEPS_DIR" 2>/dev/null || echo "(empty)"
          echo "::endgroup::"

      - name: Check for run-all-tests label
        id: check-label
        if: github.event_name == 'pull_request'
        run: |
          LABELS='${{ toJson(github.event.pull_request.labels.*.name) }}'
          if echo "$LABELS" | grep -q "run-all-tests"; then
            echo "force_all=true" >> $GITHUB_OUTPUT
          else
            echo "force_all=false" >> $GITHUB_OUTPUT
          fi

      - name: Read pyproject.toml
        id: config
        run: |
          echo "::group::Reading pyproject.toml"

          if [ ! -f pyproject.toml ]; then
            echo "::error::pyproject.toml not found"
            exit 1
          fi

          # Extract test_enabled from [odoo.testing] section (preferred) or fall back to fast_tests from [odoo]
          TEST_ENABLED=$(awk '/^\[odoo\.testing\]/{flag=1; next} /^\[/{flag=0} flag' pyproject.toml | \
                         grep -E "^enabled\s*=" | head -1 | \
                         sed 's/.*=\s*//; s/[" ]//g')
          if [ -z "$TEST_ENABLED" ]; then
            # Fall back to fast_tests for backwards compatibility
            TEST_ENABLED=$(grep -E "^fast_tests\s*=" pyproject.toml | head -1 | sed 's/#.*//; s/.*=\s*//; s/[" ]//g')
          fi
          if [ -z "$TEST_ENABLED" ]; then
            # Fall back to test_enabled in [odoo] section
            TEST_ENABLED=$(grep -E "^test_enabled\s*=" pyproject.toml | head -1 | sed 's/#.*//; s/.*=\s*//; s/[" ]//g')
          fi
          if [ "$TEST_ENABLED" != "true" ]; then
            TEST_ENABLED="false"
          fi
          echo "test-enabled=$TEST_ENABLED" >> $GITHUB_OUTPUT
          echo "Test Enabled: $TEST_ENABLED"

          # Extract edition (enterprise/community)
          ODOO_EDITION=$(grep -E "^edition\s*=" pyproject.toml | head -1 | sed 's/.*=\s*//; s/[" ]//g')
          if [ -z "$ODOO_EDITION" ]; then
            ODOO_EDITION="enterprise"
          fi
          echo "odoo-edition=$ODOO_EDITION" >> $GITHUB_OUTPUT
          echo "Odoo Edition: $ODOO_EDITION"

          # Extract test_tags from [odoo.testing] (optional override)
          # If [odoo.testing] section exists but test_tags is not set, run ALL tests
          TEST_TAGS=$(awk '/^\[odoo\.testing\]/{flag=1; next} /^\[/{flag=0} flag' pyproject.toml | \
                      grep -E "^test_tags\s*=" | head -1 | \
                      sed 's/.*=\s*//; s/[" ]//g')
          if [ -n "$TEST_TAGS" ]; then
            echo "test-tags=${TEST_TAGS}" >> $GITHUB_OUTPUT
            echo "test-tags-set=true" >> $GITHUB_OUTPUT
            echo "Test Tags (from config): $TEST_TAGS"
          else
            # Check if [odoo.testing] section exists - if so, empty means "run all"
            if grep -q '^\[odoo\.testing\]' pyproject.toml; then
              echo "test-tags=" >> $GITHUB_OUTPUT
              echo "test-tags-set=true" >> $GITHUB_OUTPUT
              echo "Test Tags: (none - will run all tests)"
            else
              echo "test-tags=" >> $GITHUB_OUTPUT
              echo "test-tags-set=false" >> $GITHUB_OUTPUT
              echo "Test Tags: (not configured - using input default)"
            fi
          fi

          echo "::endgroup::"

      - name: Check if tests are enabled
        id: check
        run: |
          if [ "${{ steps.config.outputs.test-enabled }}" != "true" ]; then
            echo "::notice::Tests are disabled in pyproject.toml (fast_tests = false)"
            echo "skip=true" >> $GITHUB_OUTPUT
          else
            echo "skip=false" >> $GITHUB_OUTPUT
          fi

      - name: Discover modules
        id: discover
        if: steps.check.outputs.skip != 'true'
        run: |
          echo "::group::Discovering modules"

          # Use test tag from config if explicitly set, otherwise use input default
          CONFIG_TEST_TAGS="${{ steps.config.outputs.test-tags }}"
          CONFIG_TEST_TAGS_SET="${{ steps.config.outputs.test-tags-set }}"
          INPUT_TEST_TAGS="${{ inputs.test-tags }}"

          if [ "$CONFIG_TEST_TAGS_SET" == "true" ]; then
            # Config explicitly set (even if empty = run all tests)
            TEST_TAG="$CONFIG_TEST_TAGS"
          else
            # No [odoo.testing] section - use input default
            TEST_TAG="$INPUT_TEST_TAGS"
          fi
          echo "Effective test tag: $TEST_TAG"
          echo "test-tag=$TEST_TAG" >> $GITHUB_OUTPUT

          # Find modules with tests
          if [ -n "$TEST_TAG" ]; then
            # Find modules with tests containing the specific tag
            TEST_MODULES=$(find . -type f -path '*/tests/*.py' \
                           -not -path './enterprise/*' \
                           -not -path './odoo-docker-minimal/*' \
                           -not -path './deps/*' \
                           -exec grep -l "$TEST_TAG" {} \; 2>/dev/null | \
                           rev | cut -d '/' -f 3 | rev | sort -u | tr '\n' ',' | sed 's/,$//')
          else
            # No tag specified - find ALL modules with test files
            TEST_MODULES=$(find . -type f -path '*/tests/*.py' -name 'test_*.py' \
                           -not -path './enterprise/*' \
                           -not -path './odoo-docker-minimal/*' \
                           -not -path './deps/*' \
                           2>/dev/null | \
                           rev | cut -d '/' -f 3 | rev | sort -u | tr '\n' ',' | sed 's/,$//')
          fi
          echo "test-modules=$TEST_MODULES" >> $GITHUB_OUTPUT
          TEST_COUNT=$(echo "$TEST_MODULES" | tr ',' '\n' | grep -c . || echo "0")
          echo "Modules with tests ($TEST_TAG): $TEST_COUNT"
          [ -n "$TEST_MODULES" ] && echo "$TEST_MODULES" | tr ',' '\n'

          # Determine test mode based on event type
          if [ "${{ github.event_name }}" == "push" ]; then
            # Push event - always run ALL tests
            echo "Push event detected - running ALL module tests"
            MODULES="$TEST_MODULES"
            TEST_MODE="push-all"

          elif [ "${{ steps.check-label.outputs.force_all }}" == "true" ]; then
            # PR with run-all-tests label
            echo "Label 'run-all-tests' detected - running ALL module tests"
            MODULES="$TEST_MODULES"
            TEST_MODE="label-forced"

          else
            # PR event - run only affected modules
            echo "PR event - detecting affected modules..."

            # Get changed files
            git fetch origin ${{ github.base_ref }} --depth=1 2>/dev/null || true
            CHANGED_FILES=$(git diff --name-only origin/${{ github.base_ref }}...HEAD 2>/dev/null || echo "")

            # Check for shared file changes that should trigger full test
            if echo "$CHANGED_FILES" | grep -qE '^(requirements|setup\.py|pyproject\.toml|\.github/)'; then
              echo "Changes in shared/config files - running ALL tests"
              MODULES="$TEST_MODULES"
              TEST_MODE="shared-files-fallback"
            elif [ -z "$CHANGED_FILES" ]; then
              echo "Could not determine changed files - running ALL tests as fallback"
              MODULES="$TEST_MODULES"
              TEST_MODE="no-changes-fallback"
            else
              # Extract module names from changed file paths
              CHANGED_MODULES=$(echo "$CHANGED_FILES" | \
                grep -E '\.(py|xml|csv|js|scss)$' | \
                cut -d'/' -f1 | \
                sort -u | tr '\n' ',' | sed 's/,$//')

              if [ -z "$CHANGED_MODULES" ]; then
                echo "No module changes detected - running ALL tests as fallback"
                MODULES="$TEST_MODULES"
                TEST_MODE="no-changes-fallback"
              else
                # Filter to modules that have tests
                AFFECTED_WITH_TESTS=""
                for mod in $(echo "$CHANGED_MODULES" | tr ',' ' '); do
                  if echo ",$TEST_MODULES," | grep -q ",$mod,"; then
                    AFFECTED_WITH_TESTS="${AFFECTED_WITH_TESTS}${mod},"
                  fi
                done
                AFFECTED_WITH_TESTS=$(echo "$AFFECTED_WITH_TESTS" | sed 's/,$//')

                if [ -z "$AFFECTED_WITH_TESTS" ]; then
                  echo "Changed modules have no tests - running ALL tests as fallback"
                  MODULES="$TEST_MODULES"
                  TEST_MODE="no-tests-fallback"
                else
                  echo "Running tests for affected modules: $AFFECTED_WITH_TESTS"
                  MODULES="$AFFECTED_WITH_TESTS"
                  TEST_MODE="pr-filtered"
                fi
              fi
            fi
          fi

          echo "test_mode=$TEST_MODE" >> $GITHUB_OUTPUT
          echo "modules=$MODULES" >> $GITHUB_OUTPUT

          if [ -z "$MODULES" ]; then
            echo "count=0" >> $GITHUB_OUTPUT
            echo "::warning::No modules found to install"
          else
            COUNT=$(echo "$MODULES" | tr ',' '\n' | grep -c . || echo "0")
            echo "count=$COUNT" >> $GITHUB_OUTPUT
            echo "Test Mode: $TEST_MODE"
            echo "Modules to test: $MODULES"
          fi

          echo "::endgroup::"

      - name: Determine final test modules
        id: final
        if: steps.check.outputs.skip != 'true'
        run: |
          MODULES="${{ steps.discover.outputs.modules }}"
          TEST_MODULES="${{ steps.discover.outputs.test-modules }}"

          if [ -z "$MODULES" ]; then
            echo "skip=true" >> $GITHUB_OUTPUT
            echo "::notice::No modules to install"
          elif [ -z "$TEST_MODULES" ]; then
            echo "skip=true" >> $GITHUB_OUTPUT
            echo "::notice::No modules with tests found - skipping test run"
          else
            echo "skip=false" >> $GITHUB_OUTPUT
            echo "modules=$MODULES" >> $GITHUB_OUTPUT
            echo "Final modules to install: $MODULES"
            echo "Tests will run for modules: $TEST_MODULES"
          fi

      - name: Checkout odoo-docker-minimal
        if: steps.check.outputs.skip != 'true' && steps.final.outputs.skip != 'true'
        uses: actions/checkout@v4
        with:
          repository: much-GmbH/odoo-docker-minimal
          path: odoo-docker-minimal
          token: ${{ secrets.DOCKER_MINIMAL_TOKEN || secrets.CONFIG_TOKEN || github.token }}

      - name: Login to Docker registry
        if: steps.check.outputs.skip != 'true' && steps.final.outputs.skip != 'true'
        uses: docker/login-action@v3
        with:
          registry: ${{ secrets.REGISTRY_URL }}
          username: ${{ secrets.REGISTRY_USER }}
          password: ${{ secrets.REGISTRY_PASSWORD }}

      - name: Download enterprise modules
        if: steps.check.outputs.skip != 'true' && steps.final.outputs.skip != 'true' && steps.config.outputs.odoo-edition == 'enterprise'
        env:
          GITEA_TOKEN: ${{ secrets.ENTERPRISE_TOKEN }}
          GH_TOKEN: ${{ secrets.CONFIG_TOKEN || github.token }}
        run: |
          echo "::group::Downloading enterprise modules"

          if [ -z "$GITEA_TOKEN" ]; then
            echo "::error::ENTERPRISE_TOKEN not configured but edition is enterprise"
            exit 1
          fi

          # Get Odoo revision from odoo-docker-builds (uses GitHub token)
          ODOO_REVISION=$(curl -sL \
            -H "Authorization: token $GH_TOKEN" \
            "https://raw.githubusercontent.com/much-GmbH/odoo-docker-builds/main/docker/odoo-base/.env.example" | \
            grep "ODOO_REVISION" | cut -d'=' -f2)

          echo "Odoo revision: $ODOO_REVISION"

          if [ -z "$ODOO_REVISION" ]; then
            echo "::warning::Could not determine Odoo revision, using 'latest'"
            ODOO_REVISION="latest"
          fi

          # Download enterprise modules from Gitea
          # Package name format: enterprise_<major>.<minor> (e.g., enterprise_17.0)
          # Use basic auth with git user (username:token format)
          curl -L --fail --silent --show-error --max-time 120 \
            --user "git:$GITEA_TOKEN" \
            -o enterprise.zip \
            "https://vcs.muchconsulting.dev/api/packages/much-GmbH/generic/enterprise_${{ inputs.odoo-version }}.0/${ODOO_REVISION}/enterprise.zip"

          unzip -q enterprise.zip
          echo "Enterprise modules downloaded"

          echo "::endgroup::"

      - name: Configure test environment
        if: steps.check.outputs.skip != 'true' && steps.final.outputs.skip != 'true'
        run: |
          echo "::group::Configuring test environment"

          cd odoo-docker-minimal

          # Create .env file from template
          if [ -f .env.example ]; then
            cp .env.example .env
          else
            touch .env
          fi

          # Replace environment variables using sed (not append, to override template values)
          # Ensure version has .0 suffix (Docker images use 17.0, not 17)
          OD_VER="${{ inputs.odoo-version }}"
          [[ "$OD_VER" != *.* ]] && OD_VER="${OD_VER}.0"
          sed -i "s|^OD_VERSION=.*|OD_VERSION=${OD_VER}|" .env
          sed -i 's|^OD_SHELL_SCRIPT=.*|OD_SHELL_SCRIPT=|' .env
          sed -i 's|^TEST_ENABLED=.*|TEST_ENABLED=true|' .env

          # Determine effective test tags
          # If test-tag is empty (user wants all tests), use /module syntax to limit to tested modules only
          # Otherwise use the specified tag
          EFFECTIVE_TAG="${{ steps.discover.outputs.test-tag }}"
          if [ -z "$EFFECTIVE_TAG" ]; then
            # Empty tag = run all tests, but ONLY for the modules being tested (not dependencies)
            # Convert "mod1,mod2,mod3" to "/mod1,/mod2,/mod3" (comma-separated per Odoo docs)
            MODULES="${{ steps.final.outputs.modules }}"
            # Clean modules: remove any spaces, newlines, and normalize commas
            MODULES=$(echo "$MODULES" | tr -d ' \n\r' | tr -s ',')
            EFFECTIVE_TAG=$(echo "$MODULES" | sed 's/,/,\//g' | sed 's/^/\//')
            echo "Module-scoped test tags: $EFFECTIVE_TAG"
          fi
          echo "Final TEST_TAGS value: $EFFECTIVE_TAG"
          # Quote the value to preserve commas in docker-compose
          sed -i "s|^TEST_TAGS=.*|TEST_TAGS=\"${EFFECTIVE_TAG}\"|" .env
          sed -i 's|^BASE_MODULES=.*|BASE_MODULES=|' .env
          sed -i 's|^CUSTOM_MODULES=.*|CUSTOM_MODULES=${{ steps.final.outputs.modules }}|' .env
          sed -i 's|^VCPUS=.*|VCPUS=2|' .env

          echo "Environment configured:"
          cat .env

          echo "::endgroup::"

      - name: Link dependency modules
        if: steps.check.outputs.skip != 'true' && steps.final.outputs.skip != 'true'
        run: |
          # Symlink dependency modules into workspace root so Odoo finds them
          if [ -d "${{ github.workspace }}/deps" ]; then
            echo "::group::Linking dependency modules"
            for dep_repo in ${{ github.workspace }}/deps/*/; do
              [ -d "$dep_repo" ] || continue
              # Find all Odoo modules (directories with __manifest__.py)
              find "$dep_repo" -maxdepth 2 -name "__manifest__.py" -type f | while read manifest; do
                module_dir=$(dirname "$manifest")
                module_name=$(basename "$module_dir")
                # Skip if already exists in workspace
                if [ ! -e "${{ github.workspace }}/$module_name" ]; then
                  ln -s "$module_dir" "${{ github.workspace }}/$module_name"
                  echo "Linked: $module_name -> $module_dir"
                fi
              done
            done
            echo "::endgroup::"
          fi

      - name: Run tests
        id: tests
        if: steps.check.outputs.skip != 'true' && steps.final.outputs.skip != 'true'
        run: |
          echo "::group::Running Odoo unit tests"

          cd odoo-docker-minimal

          # Single addons path - dependencies are symlinked into workspace
          export OD_ADDONS_MOUNT_PATH="${{ github.workspace }}"
          echo "Addons path: $OD_ADDONS_MOUNT_PATH"

          # Pull images and start postgres
          docker compose pull
          docker compose up postgres -d

          # Wait for postgres to be ready
          echo "Waiting for PostgreSQL..."
          sleep 10

          # Run tests
          START_TIME=$(date +%s)
          TEST_EXIT_CODE=0
          docker compose up odoo --exit-code-from odoo || TEST_EXIT_CODE=$?
          END_TIME=$(date +%s)
          DURATION=$((END_TIME - START_TIME))
          echo "duration=$DURATION" >> $GITHUB_OUTPUT

          # Capture logs before checking result
          docker compose logs odoo > /tmp/odoo-test-logs.txt 2>&1 || true

          echo "::endgroup::"

          # Exit with test result (step fails if tests failed)
          if [ $TEST_EXIT_CODE -ne 0 ]; then
            echo "result=fail" >> $GITHUB_OUTPUT
            echo "::error::Tests failed with exit code $TEST_EXIT_CODE"
            exit $TEST_EXIT_CODE
          else
            echo "result=pass" >> $GITHUB_OUTPUT
            echo "Tests passed!"
          fi

      - name: Cleanup
        if: always() && steps.check.outputs.skip != 'true' && steps.final.outputs.skip != 'true'
        run: |
          cd odoo-docker-minimal 2>/dev/null && docker compose down --volumes || true

      - name: Extract test errors
        id: errors
        if: steps.tests.outputs.result == 'fail'
        run: |
          echo "::group::Extracting test errors"

          if [ -f /tmp/odoo-test-logs.txt ]; then
            # Extract error messages from Odoo logs
            ERRORS=$(grep -E "(ERROR|FAIL|AssertionError|Exception)" /tmp/odoo-test-logs.txt | \
                     tail -20 | \
                     sed 's/^/- /')

            if [ -n "$ERRORS" ]; then
              echo "errors<<EOF" >> $GITHUB_OUTPUT
              echo "$ERRORS" >> $GITHUB_OUTPUT
              echo "EOF" >> $GITHUB_OUTPUT
            else
              echo "errors=Test execution failed. Check workflow logs for details." >> $GITHUB_OUTPUT
            fi
          else
            echo "errors=No test logs available." >> $GITHUB_OUTPUT
          fi

          echo "::endgroup::"

      - name: Extract test results
        id: results
        if: always() && steps.check.outputs.skip != 'true' && steps.final.outputs.skip != 'true'
        run: |
          if [ ! -f /tmp/odoo-test-logs.txt ]; then
            echo "found=false" >> $GITHUB_OUTPUT
            exit 0
          fi

          # Parse overall results: "X failed, Y error(s) of Z tests"
          RESULT_LINE=$(grep -E "failed.*error.*tests" /tmp/odoo-test-logs.txt | tail -1 || true)
          if [ -z "$RESULT_LINE" ]; then
            echo "found=false" >> $GITHUB_OUTPUT
            echo "Could not parse test results from logs"
            exit 0
          fi

          TOTAL_FAILED=$(echo "$RESULT_LINE" | grep -oE '[0-9]+ failed' | grep -oE '[0-9]+' || echo "0")
          TOTAL_ERRORS=$(echo "$RESULT_LINE" | grep -oE '[0-9]+ error' | grep -oE '[0-9]+' || echo "0")
          TOTAL=$(echo "$RESULT_LINE" | grep -oE 'of [0-9]+ tests' | grep -oE '[0-9]+' || echo "0")
          TOTAL_PASSED=$((TOTAL - TOTAL_FAILED - TOTAL_ERRORS))

          echo "failed=$TOTAL_FAILED" >> $GITHUB_OUTPUT
          echo "errors=$TOTAL_ERRORS" >> $GITHUB_OUTPUT
          echo "total=$TOTAL" >> $GITHUB_OUTPUT
          echo "passed=$TOTAL_PASSED" >> $GITHUB_OUTPUT
          echo "found=true" >> $GITHUB_OUTPUT

          echo "Test Results: $TOTAL_PASSED passed, $TOTAL_FAILED failed, $TOTAL_ERRORS errors (total: $TOTAL)"

          # Build per-module results JSON
          MODULES="${{ steps.final.outputs.modules }}"
          RESULTS_JSON="["

          for module in $(echo "$MODULES" | tr ',' ' '); do
            # Count failures and errors for this module (strip newlines from grep -c output)
            MOD_FAILED=$(grep -c "FAIL:.*odoo\.addons\.${module}\." /tmp/odoo-test-logs.txt 2>/dev/null | tr -d '\n' || echo -n "0")
            MOD_ERRORS=$(grep -c "ERROR:.*odoo\.addons\.${module}\." /tmp/odoo-test-logs.txt 2>/dev/null | tr -d '\n' || echo -n "0")
            # Ensure we have valid numbers
            [ -z "$MOD_FAILED" ] && MOD_FAILED=0
            [ -z "$MOD_ERRORS" ] && MOD_ERRORS=0

            # Extract failed test names for this module
            FAILED_TESTS=$(grep -oE "FAIL: [^ ]+ \(odoo\.addons\.${module}\.[^)]+\)" /tmp/odoo-test-logs.txt 2>/dev/null | sed 's/FAIL: \([^ ]*\).*/\1/' | tr '\n' ',' | sed 's/,$//' || true)

            RESULTS_JSON="${RESULTS_JSON}{\"module\":\"${module}\",\"failed\":${MOD_FAILED},\"errors\":${MOD_ERRORS},\"failed_tests\":\"${FAILED_TESTS}\"},"
          done

          RESULTS_JSON="${RESULTS_JSON%,}]"
          echo "per_module=${RESULTS_JSON}" >> $GITHUB_OUTPUT
          echo "Per-module results: $RESULTS_JSON"

      - name: Generate Summary
        id: summary
        if: always()
        run: |
          echo "## Unit Test Results" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Odoo Version**: ${{ inputs.odoo-version }}" >> $GITHUB_STEP_SUMMARY
          echo "**Test Tags**: ${{ steps.discover.outputs.test-tag || 'all' }}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY

          TESTS_PASSED=true

          # Check if tests were skipped
          if [ "${{ steps.check.outputs.skip }}" == "true" ]; then
            echo "| Status | :fast_forward: Skipped (fast_tests = false) |" >> $GITHUB_STEP_SUMMARY
            echo "tests-passed=true" >> $GITHUB_OUTPUT
          elif [ "${{ steps.final.outputs.skip }}" == "true" ]; then
            echo "| Status | :fast_forward: Skipped (no modules to test) |" >> $GITHUB_STEP_SUMMARY
            echo "tests-passed=true" >> $GITHUB_OUTPUT
          elif [ "${{ steps.tests.outputs.result }}" == "pass" ]; then
            echo "| Status | :white_check_mark: Passed |" >> $GITHUB_STEP_SUMMARY
            echo "| Modules | ${{ steps.final.outputs.modules }} |" >> $GITHUB_STEP_SUMMARY
            echo "| Test Mode | ${{ steps.discover.outputs.test_mode }} |" >> $GITHUB_STEP_SUMMARY
            echo "| Duration | ${{ steps.tests.outputs.duration }}s |" >> $GITHUB_STEP_SUMMARY
            echo "tests-passed=true" >> $GITHUB_OUTPUT
          else
            echo "| Status | :x: Failed |" >> $GITHUB_STEP_SUMMARY
            echo "| Modules | ${{ steps.final.outputs.modules }} |" >> $GITHUB_STEP_SUMMARY
            echo "| Test Mode | ${{ steps.discover.outputs.test_mode }} |" >> $GITHUB_STEP_SUMMARY
            echo "| Duration | ${{ steps.tests.outputs.duration }}s |" >> $GITHUB_STEP_SUMMARY
            echo "tests-passed=false" >> $GITHUB_OUTPUT
            TESTS_PASSED=false
          fi

          echo "" >> $GITHUB_STEP_SUMMARY

          if [ "$TESTS_PASSED" == "true" ]; then
            echo "### :tada: Tests completed successfully!" >> $GITHUB_STEP_SUMMARY
          else
            echo "### :warning: Tests failed" >> $GITHUB_STEP_SUMMARY
          fi

      - name: Comment on PR
        if: always() && github.event_name == 'pull_request'
        uses: actions/github-script@v7
        env:
          TEST_ERRORS: ${{ steps.errors.outputs.errors }}
          PER_MODULE: ${{ steps.results.outputs.per_module }}
        with:
          script: |
            const skipped = '${{ steps.check.outputs.skip }}' === 'true' || '${{ steps.final.outputs.skip }}' === 'true';
            const testsPassed = '${{ steps.tests.outputs.result }}' === 'pass';
            const errors = process.env.TEST_ERRORS || '';

            // Test results from parsed logs
            const resultsFound = '${{ steps.results.outputs.found }}' === 'true';
            const totalTests = parseInt('${{ steps.results.outputs.total }}') || 0;
            const passedTests = parseInt('${{ steps.results.outputs.passed }}') || 0;
            const failedTests = parseInt('${{ steps.results.outputs.failed }}') || 0;
            const errorTests = parseInt('${{ steps.results.outputs.errors }}') || 0;

            // Parse per-module results
            let perModule = [];
            try {
              const perModuleRaw = process.env.PER_MODULE || '[]';
              perModule = JSON.parse(perModuleRaw);
            } catch (e) {
              console.log('Failed to parse per_module:', e);
            }

            let status;
            if (skipped) {
              if ('${{ steps.check.outputs.skip }}' === 'true') {
                status = 'Skipped (fast_tests = false)';
              } else {
                status = 'Skipped (no modules to test)';
              }
            }

            let body = `## üß™ Test Results\n\n`;

            // Header based on status
            if (skipped) {
              body += `### ‚è≠Ô∏è ${status}\n\n`;
            } else if (testsPassed) {
              body += `### ‚úÖ All tests passed (${totalTests} total)\n\n`;
            } else {
              const failCount = failedTests + errorTests;
              body += `### ‚ùå ${failCount} test${failCount !== 1 ? 's' : ''} failed\n\n`;
            }

            // Per-module table
            if (!skipped && perModule.length > 0) {
              const hasFailures = !testsPassed;

              if (hasFailures) {
                body += `| Module | Passed | Failed | Status |\n`;
                body += `|--------|--------|--------|--------|\n`;
              } else {
                body += `| Module | Tests | Status |\n`;
                body += `|--------|-------|--------|\n`;
              }

              for (const mod of perModule) {
                const modFailed = (mod.failed || 0) + (mod.errors || 0);
                const modStatus = modFailed > 0 ? '‚ùå' : '‚úÖ';

                if (hasFailures) {
                  const modPassed = modFailed > 0 ? '?' : '‚úì';
                  body += `| \`${mod.module}\` | ${modPassed} | ${modFailed} | ${modStatus} |\n`;
                } else {
                  body += `| \`${mod.module}\` | ‚úì | ${modStatus} |\n`;
                }
              }
              body += `\n`;
            }

            // Failed test details
            if (!skipped && !testsPassed && perModule.length > 0) {
              const modulesWithFailures = perModule.filter(m => m.failed_tests);
              if (modulesWithFailures.length > 0) {
                body += `<details>\n<summary>‚ùå <b>Failed Tests</b></summary>\n\n`;
                for (const mod of modulesWithFailures) {
                  if (mod.failed_tests) {
                    body += `**${mod.module}**:\n`;
                    for (const test of mod.failed_tests.split(',')) {
                      if (test) body += `- \`${test}\`\n`;
                    }
                    body += `\n`;
                  }
                }
                body += `</details>\n\n`;
              }
            }

            // Show raw errors if available and no per-module parsing
            if (!skipped && !testsPassed && errors && perModule.filter(m => m.failed_tests).length === 0) {
              body += `<details>\n<summary>‚ùå <b>Test Errors</b></summary>\n\n`;
              body += `\`\`\`\n${errors.trim()}\n\`\`\`\n`;
              body += `</details>\n\n`;
            }

            body += `üìã [View full logs](${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }})`;

            // Find existing comment to update
            const { data: comments } = await github.rest.issues.listComments({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.issue.number
            });

            const botComment = comments.find(c =>
              c.user.type === 'Bot' && c.body.includes('Unit Test Results')
            );

            if (botComment) {
              await github.rest.issues.updateComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                comment_id: botComment.id,
                body
              });
            } else {
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: context.issue.number,
                body
              });
            }

      - name: Enforce strict mode
        if: ${{ inputs.strict-mode && steps.summary.outputs.tests-passed == 'false' }}
        run: |
          echo "::error::Tests failed in strict mode"
          exit 1
