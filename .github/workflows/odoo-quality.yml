# Consolidated Odoo Quality Checks - Cost Optimized
# Single job runs all tools sequentially to minimize GitHub Actions minutes
# Billing: GitHub rounds each job up to nearest minute, so 5 parallel 30-second jobs = 5 min billed
# This workflow: ~3-4 min actual = 4 min billed (saves 20-40%)

name: Odoo Quality Checks

on:
  workflow_call:
    # Note: Concurrency should be set in the calling workflow, not here
    # This allows the caller to define the concurrency group based on their context
    inputs:
      odoo-version:
        description: 'Odoo version (14, 15, 16, 17, 18)'
        required: true
        type: string
      python-version:
        description: 'Python version'
        required: false
        type: string
        default: '3.10'
      skip-sonar:
        description: 'Skip SonarQube analysis'
        required: false
        type: boolean
        default: false
      strict-mode:
        description: 'Fail workflow on any check failure'
        required: false
        type: boolean
        default: false
    secrets:
      CONFIG_TOKEN:
        description: 'PAT with repo scope to access private github-actions repo (only needed if repo is private)'
        required: false
      SONAR_TOKEN:
        required: false
      SONAR_HOST_URL:
        required: false
    outputs:
      quality-passed:
        description: 'Whether all quality checks passed'
        value: ${{ jobs.quality.outputs.all-passed }}

jobs:
  quality:
    name: Quality Checks (Odoo ${{ inputs.odoo-version }})
    runs-on: ubuntu-latest
    permissions:
      contents: read
      pull-requests: write
    outputs:
      all-passed: ${{ steps.summary.outputs.all-passed }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          # For PRs: checkout the PR branch (gets latest including auto-format commits)
          # For push: checkout the default ref
          ref: ${{ github.head_ref || github.ref }}
          fetch-depth: 0  # Full history for SonarQube blame

      - name: Set up Python ${{ inputs.python-version }}
        uses: actions/setup-python@v5
        with:
          python-version: ${{ inputs.python-version }}

      - name: Cache pip packages
        uses: actions/cache@v4
        with:
          path: ~/.cache/pip
          key: ${{ runner.os }}-pip-${{ inputs.odoo-version }}-${{ hashFiles('**/requirements*.txt', '**/dev-requirements*.txt') }}
          restore-keys: |
            ${{ runner.os }}-pip-${{ inputs.odoo-version }}-
            ${{ runner.os }}-pip-

      - name: Download dev-requirements from central repo
        env:
          # Use CONFIG_TOKEN if provided (for private repo), otherwise github.token (for public repo)
          GH_TOKEN: ${{ secrets.CONFIG_TOKEN || github.token }}
        run: |
          echo "::group::Downloading dev-requirements from github-actions repo"

          # Function to download file from repo via GitHub API
          download_file() {
            local file_path=$1
            local output_path=$2
            echo "Downloading $file_path..."

            HTTP_CODE=$(curl -sL -w "%{http_code}" \
              -H "Authorization: token $GH_TOKEN" \
              -H "Accept: application/vnd.github.v3.raw" \
              "https://api.github.com/repos/${{ github.repository_owner }}/github-actions/contents/$file_path" \
              -o "$output_path")

            if [ "$HTTP_CODE" != "200" ]; then
              echo "::error::Failed to download $file_path (HTTP $HTTP_CODE)"
              echo "::error::If github-actions repo is private, set CONFIG_TOKEN org secret with a PAT that has repo scope"
              cat "$output_path"  # Show error response
              return 1
            fi
          }

          # Download requirements
          download_file "dev-requirements/base.txt" "/tmp/base.txt" || exit 1
          download_file "dev-requirements/odoo${{ inputs.odoo-version }}.txt" "/tmp/odoo.txt" || exit 1

          echo "Downloaded files:"
          ls -la /tmp/*.txt
          echo "::endgroup::"

      - name: Verify local configs
        run: |
          echo "::group::Checking local config files"
          # Configs should exist in the repo (inherited from base-repo template)
          for config in .flake8 .bandit .pylintrc; do
            if [ -f "$config" ]; then
              echo "âœ“ Found $config"
            else
              echo "::warning::Missing $config - using defaults"
            fi
          done
          echo "::endgroup::"

      - name: Install quality tools
        run: |
          echo "::group::Installing quality tools"
          cat /tmp/base.txt
          cat /tmp/odoo.txt
          pip install -q -r /tmp/base.txt -r /tmp/odoo.txt
          echo "::endgroup::"

      - name: Check unreleased dependencies
        id: deps
        continue-on-error: true
        run: |
          echo "::group::Unreleased Dependencies Check"
          FOUND_UNRELEASED=false
          for f in requirements.txt test-requirements.txt; do
            if [ -f "$f" ]; then
              # Check for git-based dependencies (URLs with /)
              if grep -E "^[^#].*/" "$f" 2>/dev/null; then
                echo "::warning::Found git-based or unreleased dependencies in $f"
                FOUND_UNRELEASED=true
              fi
            fi
          done
          if [ "$FOUND_UNRELEASED" = "true" ]; then
            echo "result=warn" >> $GITHUB_OUTPUT
          else
            echo "result=pass" >> $GITHUB_OUTPUT
            echo "No unreleased dependencies found"
          fi
          echo "::endgroup::"

      - name: Black (formatting)
        id: black
        continue-on-error: true
        run: |
          echo "::group::Black Check"
          if python -m black --check --diff .; then
            echo "result=pass" >> $GITHUB_OUTPUT
            echo "Black: All files properly formatted"
          else
            echo "result=fail" >> $GITHUB_OUTPUT
            echo "::warning::Black formatting issues found. Run 'black .' locally to fix."
            echo ""
            echo "To auto-fix formatting before commits, set up pre-commit hooks:"
            echo "  pip install pre-commit && pre-commit install"
            echo ""
            echo "See: https://github.com/${{ github.repository_owner }}/github-actions/blob/main/.github/docs/PRE_COMMIT.md"
          fi
          echo "::endgroup::"

      - name: Flake8 (linting)
        id: flake8
        continue-on-error: true
        run: |
          echo "::group::Flake8 Check"
          if python -m flake8 . --config=.flake8; then
            echo "result=pass" >> $GITHUB_OUTPUT
            echo "Flake8: No issues found"
          else
            echo "result=fail" >> $GITHUB_OUTPUT
            echo "::warning::Flake8 linting issues found"
          fi
          echo "::endgroup::"

      - name: Pylint-Odoo
        id: pylint
        continue-on-error: true
        run: |
          echo "::group::Pylint-Odoo Check"
          # Find all Odoo modules
          MODULES=$(find . -name '__manifest__.py' -exec dirname {} \; | sort -u | tr '\n' ' ')

          if [ -z "$MODULES" ]; then
            echo "No Odoo modules found (no __manifest__.py files)"
            echo "result=skip" >> $GITHUB_OUTPUT
          else
            echo "Found modules: $MODULES"

            if python -m pylint $MODULES --rcfile=.pylintrc --output-format=colorized; then
              echo "result=pass" >> $GITHUB_OUTPUT
              echo "Pylint-Odoo: No issues found"
            else
              echo "result=fail" >> $GITHUB_OUTPUT
              echo "::warning::Pylint-Odoo issues found"
            fi
          fi
          echo "::endgroup::"

      - name: Radon (complexity)
        id: radon
        continue-on-error: true
        run: |
          echo "::group::Radon Complexity Check"
          python -m radon cc . -a -nc --total-average

          # Check average complexity grade
          AVG=$(python -m radon cc . -a -nc --total-average 2>/dev/null | grep "Average complexity" | grep -oE '[A-F]' | head -1)
          echo "Average complexity grade: $AVG"

          if [[ "$AVG" =~ ^[DE]$ ]]; then
            echo "result=warn" >> $GITHUB_OUTPUT
            echo "::warning::High average complexity: $AVG"
          else
            echo "result=pass" >> $GITHUB_OUTPUT
            echo "Radon: Complexity within acceptable range"
          fi
          echo "::endgroup::"

      - name: Bandit (security)
        id: bandit
        continue-on-error: true
        run: |
          echo "::group::Bandit Security Check"
          if python -m bandit -r . -c .bandit -f custom \
            --msg-template "{relpath}:{line}: [{severity}] {test_id}: {msg}"; then
            echo "result=pass" >> $GITHUB_OUTPUT
            echo "Bandit: No security issues found"
          else
            echo "result=fail" >> $GITHUB_OUTPUT
            echo "::warning::Bandit security issues found"
          fi
          echo "::endgroup::"

      - name: SonarQube Scan
        if: ${{ !inputs.skip-sonar }}
        id: sonar
        continue-on-error: true
        uses: SonarSource/sonarqube-scan-action@v6
        with:
          args: >
            -Dsonar.projectKey=${{ github.event.repository.name }}
            -Dsonar.organization=${{ github.repository_owner }}
            -Dsonar.sources=./
            -Dsonar.python.version=${{ inputs.python-version }}
            ${{ github.event_name == 'pull_request' &&
                format('-Dsonar.pullrequest.key={0} -Dsonar.pullrequest.branch={1} -Dsonar.pullrequest.base={2}',
                       github.event.pull_request.number, github.head_ref, github.base_ref) ||
                format('-Dsonar.branch.name={0}', github.ref_name) }}
        env:
          SONAR_TOKEN: ${{ secrets.SONAR_TOKEN }}
          SONAR_HOST_URL: ${{ secrets.SONAR_HOST_URL }}

      - name: SonarQube Quality Gate
        if: ${{ !inputs.skip-sonar && steps.sonar.outcome == 'success' }}
        uses: SonarSource/sonarqube-quality-gate-action@v1.2.0
        continue-on-error: true  # Don't fail workflow on quality gate
        timeout-minutes: 5
        env:
          SONAR_TOKEN: ${{ secrets.SONAR_TOKEN }}
          SONAR_HOST_URL: ${{ secrets.SONAR_HOST_URL }}

      - name: Generate Summary
        id: summary
        if: always()
        run: |
          echo "## Quality Check Results" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Odoo Version**: ${{ inputs.odoo-version }}" >> $GITHUB_STEP_SUMMARY
          echo "**Python Version**: ${{ inputs.python-version }}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "| Tool | Status |" >> $GITHUB_STEP_SUMMARY
          echo "|------|--------|" >> $GITHUB_STEP_SUMMARY

          ALL_PASSED=true

          # Unreleased Dependencies
          if [ "${{ steps.deps.outputs.result }}" == "pass" ]; then
            echo "| Dependencies | :white_check_mark: All published |" >> $GITHUB_STEP_SUMMARY
          else
            echo "| Dependencies | :warning: Unreleased deps found |" >> $GITHUB_STEP_SUMMARY
          fi

          # Black
          if [ "${{ steps.black.outputs.result }}" == "pass" ]; then
            echo "| Black | :white_check_mark: Passed |" >> $GITHUB_STEP_SUMMARY
          else
            echo "| Black | :x: Failed |" >> $GITHUB_STEP_SUMMARY
            ALL_PASSED=false
          fi

          # Flake8
          if [ "${{ steps.flake8.outputs.result }}" == "pass" ]; then
            echo "| Flake8 | :white_check_mark: Passed |" >> $GITHUB_STEP_SUMMARY
          else
            echo "| Flake8 | :x: Failed |" >> $GITHUB_STEP_SUMMARY
            ALL_PASSED=false
          fi

          # Pylint
          if [ "${{ steps.pylint.outputs.result }}" == "pass" ]; then
            echo "| Pylint-Odoo | :white_check_mark: Passed |" >> $GITHUB_STEP_SUMMARY
          elif [ "${{ steps.pylint.outputs.result }}" == "skip" ]; then
            echo "| Pylint-Odoo | :fast_forward: Skipped (no modules) |" >> $GITHUB_STEP_SUMMARY
          else
            echo "| Pylint-Odoo | :x: Failed |" >> $GITHUB_STEP_SUMMARY
            ALL_PASSED=false
          fi

          # Radon
          if [ "${{ steps.radon.outputs.result }}" == "pass" ]; then
            echo "| Radon | :white_check_mark: Passed |" >> $GITHUB_STEP_SUMMARY
          elif [ "${{ steps.radon.outputs.result }}" == "warn" ]; then
            echo "| Radon | :warning: High complexity |" >> $GITHUB_STEP_SUMMARY
          else
            echo "| Radon | :x: Failed |" >> $GITHUB_STEP_SUMMARY
          fi

          # Bandit
          if [ "${{ steps.bandit.outputs.result }}" == "pass" ]; then
            echo "| Bandit | :white_check_mark: Passed |" >> $GITHUB_STEP_SUMMARY
          else
            echo "| Bandit | :x: Security issues |" >> $GITHUB_STEP_SUMMARY
            ALL_PASSED=false
          fi

          # SonarQube
          if [ "${{ inputs.skip-sonar }}" == "true" ]; then
            echo "| SonarQube | :fast_forward: Skipped |" >> $GITHUB_STEP_SUMMARY
          elif [ "${{ steps.sonar.outcome }}" == "skipped" ]; then
            echo "| SonarQube | :fast_forward: Not configured |" >> $GITHUB_STEP_SUMMARY
          else
            echo "| SonarQube | :white_check_mark: Analyzed |" >> $GITHUB_STEP_SUMMARY
          fi

          echo "" >> $GITHUB_STEP_SUMMARY
          echo "all-passed=$ALL_PASSED" >> $GITHUB_OUTPUT

          if [ "$ALL_PASSED" == "true" ]; then
            echo "### :tada: All checks passed!" >> $GITHUB_STEP_SUMMARY
          else
            echo "### :warning: Some checks failed" >> $GITHUB_STEP_SUMMARY
          fi

      - name: Comment on PR
        if: ${{ always() && github.event_name == 'pull_request' }}
        uses: actions/github-script@v7
        with:
          script: |
            const results = {
              deps: '${{ steps.deps.outputs.result }}',
              black: '${{ steps.black.outputs.result }}',
              flake8: '${{ steps.flake8.outputs.result }}',
              pylint: '${{ steps.pylint.outputs.result }}',
              radon: '${{ steps.radon.outputs.result }}',
              bandit: '${{ steps.bandit.outputs.result }}'
            };

            const getStatus = (tool, result) => {
              if (result === 'pass') return 'âœ… Passed';
              if (result === 'skip') return 'â­ï¸ Skipped';
              if (result === 'warn') return 'âš ï¸ Warning';
              return 'âŒ Failed';
            };

            const allPassed = '${{ steps.summary.outputs.all-passed }}' === 'true';

            let body = `## Quality Check Results\n\n`;
            body += `| Tool | Status |\n|------|--------|\n`;
            body += `| Dependencies | ${getStatus('deps', results.deps)} |\n`;
            body += `| Black (formatting) | ${getStatus('black', results.black)} |\n`;
            body += `| Flake8 (linting) | ${getStatus('flake8', results.flake8)} |\n`;
            body += `| Pylint-Odoo | ${getStatus('pylint', results.pylint)} |\n`;
            body += `| Radon (complexity) | ${getStatus('radon', results.radon)} |\n`;
            body += `| Bandit (security) | ${getStatus('bandit', results.bandit)} |\n\n`;

            if (allPassed) {
              body += `### ðŸŽ‰ All checks passed!`;
            } else {
              body += `### âš ï¸ Some checks need attention\n\n`;
              body += `View the [workflow run](${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}) for details.`;
            }

            // Find existing comment to update
            const { data: comments } = await github.rest.issues.listComments({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.issue.number
            });

            const botComment = comments.find(c =>
              c.user.type === 'Bot' && c.body.includes('Quality Check Results')
            );

            if (botComment) {
              await github.rest.issues.updateComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                comment_id: botComment.id,
                body
              });
            } else {
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: context.issue.number,
                body
              });
            }

      - name: Enforce strict mode
        if: ${{ inputs.strict-mode && steps.summary.outputs.all-passed == 'false' }}
        run: |
          echo "::error::Quality checks failed in strict mode"
          exit 1
