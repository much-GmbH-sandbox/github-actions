# Consolidated Odoo Quality Checks - Cost Optimized
# Single job runs all tools sequentially to minimize GitHub Actions minutes
# Billing: GitHub rounds each job up to nearest minute, so 5 parallel 30-second jobs = 5 min billed
# This workflow: ~3-4 min actual = 4 min billed (saves 20-40%)

name: Odoo Quality Checks

on:
  workflow_call:
    # Note: Concurrency should be set in the calling workflow, not here
    # This allows the caller to define the concurrency group based on their context
    inputs:
      odoo-version:
        description: 'Odoo version (14, 15, 16, 17, 18)'
        required: true
        type: string
      python-version:
        description: 'Python version'
        required: false
        type: string
        default: '3.10'
      skip-sonar:
        description: 'Skip SonarQube analysis'
        required: false
        type: boolean
        default: false
      strict-mode:
        description: 'Fail workflow on any check failure'
        required: false
        type: boolean
        default: false
    secrets:
      CONFIG_TOKEN:
        description: 'PAT with repo scope to access private github-actions repo (only needed if repo is private)'
        required: false
      SONAR_TOKEN:
        required: false
      SONAR_HOST_URL:
        required: false
    outputs:
      quality-passed:
        description: 'Whether all quality checks passed'
        value: ${{ jobs.quality.outputs.all-passed }}

jobs:
  quality:
    name: Quality Checks (Odoo ${{ inputs.odoo-version }})
    runs-on: ubuntu-latest
    permissions:
      contents: read
      pull-requests: write
    outputs:
      all-passed: ${{ steps.summary.outputs.all-passed }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          # For PRs: checkout the PR branch (gets latest including auto-format commits)
          # For push: checkout the default ref
          ref: ${{ github.head_ref || github.ref }}
          fetch-depth: 0  # Full history for SonarQube blame

      - name: Set up Python ${{ inputs.python-version }}
        uses: actions/setup-python@v5
        with:
          python-version: ${{ inputs.python-version }}

      - name: Cache pip packages
        uses: actions/cache@v4
        with:
          path: ~/.cache/pip
          key: ${{ runner.os }}-pip-${{ inputs.odoo-version }}-${{ hashFiles('**/requirements*.txt', '**/dev-requirements*.txt') }}
          restore-keys: |
            ${{ runner.os }}-pip-${{ inputs.odoo-version }}-
            ${{ runner.os }}-pip-

      - name: Download dev-requirements from central repo
        env:
          # Use CONFIG_TOKEN if provided (for private repo), otherwise github.token (for public repo)
          GH_TOKEN: ${{ secrets.CONFIG_TOKEN || github.token }}
        run: |
          echo "::group::Downloading dev-requirements from github-actions repo"

          # Function to download file from repo via GitHub API
          download_file() {
            local file_path=$1
            local output_path=$2
            echo "Downloading $file_path..."

            HTTP_CODE=$(curl -sL -w "%{http_code}" \
              -H "Authorization: token $GH_TOKEN" \
              -H "Accept: application/vnd.github.v3.raw" \
              "https://api.github.com/repos/${{ github.repository_owner }}/github-actions/contents/$file_path" \
              -o "$output_path")

            if [ "$HTTP_CODE" != "200" ]; then
              echo "::error::Failed to download $file_path (HTTP $HTTP_CODE)"
              echo "::error::If github-actions repo is private, set CONFIG_TOKEN org secret with a PAT that has repo scope"
              cat "$output_path"  # Show error response
              return 1
            fi
          }

          # Download requirements
          download_file "dev-requirements/base.txt" "/tmp/base.txt" || exit 1
          download_file "dev-requirements/odoo${{ inputs.odoo-version }}.txt" "/tmp/odoo.txt" || exit 1

          echo "Downloaded files:"
          ls -la /tmp/*.txt
          echo "::endgroup::"

      - name: Verify local configs
        run: |
          echo "::group::Checking local config files"
          # Configs should exist in the repo (inherited from base-template template)
          for config in .flake8 .bandit .pylintrc; do
            if [ -f "$config" ]; then
              echo "‚úì Found $config"
            else
              echo "::warning::Missing $config - using defaults"
            fi
          done
          echo "::endgroup::"

      - name: Install quality tools
        run: |
          echo "::group::Installing quality tools"
          cat /tmp/base.txt
          cat /tmp/odoo.txt
          pip install -q -r /tmp/base.txt -r /tmp/odoo.txt
          echo "::endgroup::"

      - name: Check unreleased dependencies
        id: deps
        continue-on-error: true
        run: |
          echo "::group::Unreleased Dependencies Check"
          FOUND_UNRELEASED=false
          for f in requirements.txt test-requirements.txt; do
            if [ -f "$f" ]; then
              # Check for git-based dependencies (URLs with /)
              if grep -E "^[^#].*/" "$f" 2>/dev/null; then
                echo "::warning::Found git-based or unreleased dependencies in $f"
                FOUND_UNRELEASED=true
              fi
            fi
          done
          if [ "$FOUND_UNRELEASED" = "true" ]; then
            echo "result=warn" >> $GITHUB_OUTPUT
          else
            echo "result=pass" >> $GITHUB_OUTPUT
            echo "No unreleased dependencies found"
          fi
          echo "::endgroup::"

      - name: Black (formatting)
        id: black
        continue-on-error: true
        run: |
          echo "::group::Black Check"
          OUTPUT=$(python -m black --check --diff . 2>&1) || true
          if echo "$OUTPUT" | grep -q "would reformat\|would be reformatted"; then
            echo "result=fail" >> $GITHUB_OUTPUT
            # Extract files that need reformatting (limit to 10)
            ERRORS=$(echo "$OUTPUT" | grep -E "^would reformat|would be reformatted" | head -10 | sed 's/^/- /')
            if [ -z "$ERRORS" ]; then
              ERRORS=$(echo "$OUTPUT" | grep -E "^\-\-\-|^\+\+\+" | head -10 | sed 's/^/- /')
            fi
            echo "errors<<EOF" >> $GITHUB_OUTPUT
            echo "$ERRORS" >> $GITHUB_OUTPUT
            echo "EOF" >> $GITHUB_OUTPUT
            echo "::warning::Black formatting issues found. Run 'black .' locally to fix."
            echo "$OUTPUT"
          else
            echo "result=pass" >> $GITHUB_OUTPUT
            echo "errors=" >> $GITHUB_OUTPUT
            echo "Black: All files properly formatted"
          fi
          echo "::endgroup::"

      - name: Flake8 (linting)
        id: flake8
        continue-on-error: true
        run: |
          echo "::group::Flake8 Check"
          OUTPUT=$(python -m flake8 . --config=.flake8 2>&1) || true
          if [ -n "$OUTPUT" ]; then
            echo "result=fail" >> $GITHUB_OUTPUT
            # Limit to first 10 errors
            ERRORS=$(echo "$OUTPUT" | head -10 | sed 's/^/- `/' | sed 's/$/`/')
            echo "errors<<EOF" >> $GITHUB_OUTPUT
            echo "$ERRORS" >> $GITHUB_OUTPUT
            echo "EOF" >> $GITHUB_OUTPUT
            echo "::warning::Flake8 linting issues found"
            echo "$OUTPUT"
          else
            echo "result=pass" >> $GITHUB_OUTPUT
            echo "errors=" >> $GITHUB_OUTPUT
            echo "Flake8: No issues found"
          fi
          echo "::endgroup::"

      - name: Pylint-Odoo
        id: pylint
        continue-on-error: true
        run: |
          echo "::group::Pylint-Odoo Check"
          # Find all Odoo modules
          MODULES=$(find . -name '__manifest__.py' -exec dirname {} \; | sort -u | tr '\n' ' ')

          if [ -z "$MODULES" ]; then
            echo "No Odoo modules found (no __manifest__.py files)"
            echo "result=skip" >> $GITHUB_OUTPUT
            echo "errors=" >> $GITHUB_OUTPUT
          else
            echo "Found modules: $MODULES"
            OUTPUT=$(python -m pylint $MODULES --rcfile=.pylintrc --output-format=text 2>&1) || true

            if echo "$OUTPUT" | grep -qE "^Your code has been rated at 10"; then
              echo "result=pass" >> $GITHUB_OUTPUT
              echo "errors=" >> $GITHUB_OUTPUT
              echo "Pylint-Odoo: No issues found"
            else
              echo "result=fail" >> $GITHUB_OUTPUT
              # Extract error/warning lines (limit to 10)
              # Format: file.py:line: [CODE(name), context] message
              ERRORS=$(echo "$OUTPUT" | grep -E "\.py:[0-9]+:.*\[[CWERF][0-9]+" | head -10 | sed 's/^/- `/' | sed 's/$/`/')
              echo "errors<<EOF" >> $GITHUB_OUTPUT
              echo "$ERRORS" >> $GITHUB_OUTPUT
              echo "EOF" >> $GITHUB_OUTPUT
              echo "::warning::Pylint-Odoo issues found"
              echo "$OUTPUT"
            fi
          fi
          echo "::endgroup::"

      - name: Radon (complexity)
        id: radon
        continue-on-error: true
        run: |
          echo "::group::Radon Complexity Check"
          OUTPUT=$(python -m radon cc . -a -nc --total-average 2>&1)
          echo "$OUTPUT"

          # Check average complexity grade
          AVG=$(echo "$OUTPUT" | grep "Average complexity" | grep -oE '[A-F]' | head -1)
          echo "Average complexity grade: $AVG"

          if [[ "$AVG" =~ ^[DE]$ ]]; then
            echo "result=warn" >> $GITHUB_OUTPUT
            # Get high complexity functions (D, E, F grades)
            ERRORS=$(echo "$OUTPUT" | grep -E " - [DEF] " | head -10 | sed 's/^/- `/' | sed 's/$/`/')
            echo "errors<<EOF" >> $GITHUB_OUTPUT
            echo "$ERRORS" >> $GITHUB_OUTPUT
            echo "EOF" >> $GITHUB_OUTPUT
            echo "::warning::High average complexity: $AVG"
          else
            echo "result=pass" >> $GITHUB_OUTPUT
            echo "errors=" >> $GITHUB_OUTPUT
            echo "Radon: Complexity within acceptable range"
          fi
          echo "::endgroup::"

      - name: Bandit (security)
        id: bandit
        continue-on-error: true
        run: |
          echo "::group::Bandit Security Check"
          OUTPUT=$(python -m bandit -r . -c .bandit -f custom \
            --msg-template "{relpath}:{line}: [{severity}] {test_id}: {msg}" 2>&1) || true

          if echo "$OUTPUT" | grep -qE "\[(HIGH|MEDIUM|LOW)\]"; then
            echo "result=fail" >> $GITHUB_OUTPUT
            # Extract security issues (limit to 10)
            ERRORS=$(echo "$OUTPUT" | grep -E "\[(HIGH|MEDIUM|LOW)\]" | head -10 | sed 's/^/- `/' | sed 's/$/`/')
            echo "errors<<EOF" >> $GITHUB_OUTPUT
            echo "$ERRORS" >> $GITHUB_OUTPUT
            echo "EOF" >> $GITHUB_OUTPUT
            echo "::warning::Bandit security issues found"
            echo "$OUTPUT"
          else
            echo "result=pass" >> $GITHUB_OUTPUT
            echo "errors=" >> $GITHUB_OUTPUT
            echo "Bandit: No security issues found"
          fi
          echo "::endgroup::"

      - name: SonarQube Scan
        if: ${{ !inputs.skip-sonar }}
        id: sonar
        continue-on-error: true
        uses: SonarSource/sonarqube-scan-action@v6
        with:
          args: >
            -Dsonar.projectKey=${{ github.event.repository.name }}
            -Dsonar.organization=${{ github.repository_owner }}
            -Dsonar.sources=./
            -Dsonar.python.version=${{ inputs.python-version }}
            ${{ github.event_name == 'pull_request' &&
                format('-Dsonar.pullrequest.key={0} -Dsonar.pullrequest.branch={1} -Dsonar.pullrequest.base={2}',
                       github.event.pull_request.number, github.head_ref, github.base_ref) ||
                format('-Dsonar.branch.name={0}', github.ref_name) }}
        env:
          SONAR_TOKEN: ${{ secrets.SONAR_TOKEN }}
          SONAR_HOST_URL: ${{ secrets.SONAR_HOST_URL }}

      - name: SonarQube Quality Gate
        if: ${{ !inputs.skip-sonar && steps.sonar.outcome == 'success' }}
        uses: SonarSource/sonarqube-quality-gate-action@v1.2.0
        continue-on-error: true  # Don't fail workflow on quality gate
        timeout-minutes: 5
        env:
          SONAR_TOKEN: ${{ secrets.SONAR_TOKEN }}
          SONAR_HOST_URL: ${{ secrets.SONAR_HOST_URL }}

      - name: Generate Summary
        id: summary
        if: always()
        run: |
          echo "## Quality Check Results" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Odoo Version**: ${{ inputs.odoo-version }}" >> $GITHUB_STEP_SUMMARY
          echo "**Python Version**: ${{ inputs.python-version }}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "| Tool | Status |" >> $GITHUB_STEP_SUMMARY
          echo "|------|--------|" >> $GITHUB_STEP_SUMMARY

          ALL_PASSED=true

          # Unreleased Dependencies
          if [ "${{ steps.deps.outputs.result }}" == "pass" ]; then
            echo "| Dependencies | :white_check_mark: All published |" >> $GITHUB_STEP_SUMMARY
          else
            echo "| Dependencies | :warning: Unreleased deps found |" >> $GITHUB_STEP_SUMMARY
          fi

          # Black
          if [ "${{ steps.black.outputs.result }}" == "pass" ]; then
            echo "| Black | :white_check_mark: Passed |" >> $GITHUB_STEP_SUMMARY
          else
            echo "| Black | :x: Failed |" >> $GITHUB_STEP_SUMMARY
            ALL_PASSED=false
          fi

          # Flake8
          if [ "${{ steps.flake8.outputs.result }}" == "pass" ]; then
            echo "| Flake8 | :white_check_mark: Passed |" >> $GITHUB_STEP_SUMMARY
          else
            echo "| Flake8 | :x: Failed |" >> $GITHUB_STEP_SUMMARY
            ALL_PASSED=false
          fi

          # Pylint
          if [ "${{ steps.pylint.outputs.result }}" == "pass" ]; then
            echo "| Pylint-Odoo | :white_check_mark: Passed |" >> $GITHUB_STEP_SUMMARY
          elif [ "${{ steps.pylint.outputs.result }}" == "skip" ]; then
            echo "| Pylint-Odoo | :fast_forward: Skipped (no modules) |" >> $GITHUB_STEP_SUMMARY
          else
            echo "| Pylint-Odoo | :x: Failed |" >> $GITHUB_STEP_SUMMARY
            ALL_PASSED=false
          fi

          # Radon
          if [ "${{ steps.radon.outputs.result }}" == "pass" ]; then
            echo "| Radon | :white_check_mark: Passed |" >> $GITHUB_STEP_SUMMARY
          elif [ "${{ steps.radon.outputs.result }}" == "warn" ]; then
            echo "| Radon | :warning: High complexity |" >> $GITHUB_STEP_SUMMARY
          else
            echo "| Radon | :x: Failed |" >> $GITHUB_STEP_SUMMARY
          fi

          # Bandit
          if [ "${{ steps.bandit.outputs.result }}" == "pass" ]; then
            echo "| Bandit | :white_check_mark: Passed |" >> $GITHUB_STEP_SUMMARY
          else
            echo "| Bandit | :x: Security issues |" >> $GITHUB_STEP_SUMMARY
            ALL_PASSED=false
          fi

          # SonarQube
          if [ "${{ inputs.skip-sonar }}" == "true" ]; then
            echo "| SonarQube | :fast_forward: Skipped |" >> $GITHUB_STEP_SUMMARY
          elif [ "${{ steps.sonar.outcome }}" == "skipped" ]; then
            echo "| SonarQube | :fast_forward: Not configured |" >> $GITHUB_STEP_SUMMARY
          else
            echo "| SonarQube | :white_check_mark: Analyzed |" >> $GITHUB_STEP_SUMMARY
          fi

          echo "" >> $GITHUB_STEP_SUMMARY
          echo "all-passed=$ALL_PASSED" >> $GITHUB_OUTPUT

          if [ "$ALL_PASSED" == "true" ]; then
            echo "### :tada: All checks passed!" >> $GITHUB_STEP_SUMMARY
          else
            echo "### :warning: Some checks failed" >> $GITHUB_STEP_SUMMARY
          fi

      - name: Comment on PR
        if: ${{ always() && github.event_name == 'pull_request' }}
        uses: actions/github-script@v7
        env:
          BLACK_ERRORS: ${{ steps.black.outputs.errors }}
          FLAKE8_ERRORS: ${{ steps.flake8.outputs.errors }}
          PYLINT_ERRORS: ${{ steps.pylint.outputs.errors }}
          RADON_ERRORS: ${{ steps.radon.outputs.errors }}
          BANDIT_ERRORS: ${{ steps.bandit.outputs.errors }}
        with:
          script: |
            const results = {
              deps: '${{ steps.deps.outputs.result }}',
              black: '${{ steps.black.outputs.result }}',
              flake8: '${{ steps.flake8.outputs.result }}',
              pylint: '${{ steps.pylint.outputs.result }}',
              radon: '${{ steps.radon.outputs.result }}',
              bandit: '${{ steps.bandit.outputs.result }}'
            };

            const errors = {
              black: process.env.BLACK_ERRORS || '',
              flake8: process.env.FLAKE8_ERRORS || '',
              pylint: process.env.PYLINT_ERRORS || '',
              radon: process.env.RADON_ERRORS || '',
              bandit: process.env.BANDIT_ERRORS || ''
            };

            const getStatus = (tool, result, error) => {
              if (result === 'pass') return '‚úÖ Passed';
              if (result === 'skip') return '‚è≠Ô∏è Skipped';
              if (result === 'warn') return '‚ö†Ô∏è Warning';
              return '‚ùå Failed';
            };

            const allPassed = '${{ steps.summary.outputs.all-passed }}' === 'true';

            let body = `## Quality Check Results\n\n`;
            body += `| Tool | Status |\n|------|--------|\n`;
            body += `| Dependencies | ${getStatus('deps', results.deps)} |\n`;
            body += `| Black (formatting) | ${getStatus('black', results.black)} |\n`;
            body += `| Flake8 (linting) | ${getStatus('flake8', results.flake8)} |\n`;
            body += `| Pylint-Odoo | ${getStatus('pylint', results.pylint)} |\n`;
            body += `| Radon (complexity) | ${getStatus('radon', results.radon)} |\n`;
            body += `| Bandit (security) | ${getStatus('bandit', results.bandit)} |\n\n`;

            if (allPassed) {
              body += `### üéâ All checks passed!`;
            } else {
              body += `### ‚ö†Ô∏è Some checks need attention\n\n`;

              // Add error details for failed checks
              const toolNames = {
                black: 'Black (formatting)',
                flake8: 'Flake8 (linting)',
                pylint: 'Pylint-Odoo',
                radon: 'Radon (complexity)',
                bandit: 'Bandit (security)'
              };

              for (const [tool, error] of Object.entries(errors)) {
                if (error && error.trim() && results[tool] !== 'pass') {
                  body += `<details>\n<summary><b>${toolNames[tool]}</b> issues</summary>\n\n`;
                  body += `\`\`\`\n${error.trim()}\n\`\`\`\n`;
                  body += `</details>\n\n`;
                }
              }

              body += `\nView the [workflow run](${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}) for full details.`;
            }

            // Find existing comment to update
            const { data: comments } = await github.rest.issues.listComments({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.issue.number
            });

            const botComment = comments.find(c =>
              c.user.type === 'Bot' && c.body.includes('Quality Check Results')
            );

            if (botComment) {
              await github.rest.issues.updateComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                comment_id: botComment.id,
                body
              });
            } else {
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: context.issue.number,
                body
              });
            }

      - name: Enforce strict mode
        if: ${{ inputs.strict-mode && steps.summary.outputs.all-passed == 'false' }}
        run: |
          echo "::error::Quality checks failed in strict mode"
          exit 1
